import os
import time
import torch
import argparse
import traceback
import bittensor as bt
import template
import openai
openai.api_key = "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"

def get_config():
    parser = argparse.ArgumentParser()
    parser.add_argument("--alpha", default=0.9, type=float)
    parser.add_argument("--custom", default="my_custom_value")
    parser.add_argument("--netuid", type=int, default=1)
    bt.subtensor.add_args(parser)
    bt.logging.add_args(parser)
    bt.wallet.add_args(parser)
    config = bt.config(parser)
    config.full_path = os.path.expanduser(f"{config.logging.logging_dir}/{config.wallet.name}/{config.wallet.hotkey}/netuid{config.netuid}/validator")
    if not os.path.exists(config.full_path):
        os.makedirs(config.full_path, exist_ok=True)
    return config

def main(config):
    bt.logging(config=config, logging_dir=config.full_path)
    bt.logging.info(f"Running validator for subnet: {config.netuid} on network: {config.subtensor.chain_endpoint}")

    wallet = bt.wallet(config=config)
    subtensor = bt.subtensor(config=config)
    dendrite = bt.dendrite(wallet=wallet)
    metagraph = subtensor.metagraph(config.netuid)

    if wallet.hotkey.ss58_address not in metagraph.hotkeys:
        bt.logging.error(f"Your validator: {wallet} is not registered to chain connection: {subtensor}. Run btcli register and try again.")
        exit()

    my_subnet_uid = metagraph.hotkeys.index(wallet.hotkey.ss58_address)

    scores = torch.ones_like(metagraph.S, dtype=torch.float32)
    step = 0

    while True:
        try:
            query = "breifly describe the moon"
            responses = dendrite.query(metagraph.axons, template.protocol.Openai(openai_input=query), deserialize=True)
            bt.logging.info(f"Sent query to miner: {query}")
            bt.logging.info(f"Received responses from miners: {responses}")
            start_time = time.time()
            # Get openai answer
            try:
                # Format the messages parameter as a list of dictionaries
                messages = [{"role": "user", "content": query}]
                bt.logging.debug(f"Sending query to OpenAI: {query}")

                openai_answer = openai.ChatCompletion.create(
                    model="gpt-3.5-turbo",
                    messages=messages,
                    temperature=0,
                )
                duration = round(time.time() - start_time, 4)
                bt.logging.info(f"OpenAI API request took {duration} seconds")
                openai_answer = openai_answer["choices"][0]["message"]["content"].strip()
                bt.logging.info(f"Received answer from OpenAI: {openai_answer}")

            except Exception as e:
                bt.logging.info(f"got exception when calling openai {e}")

            for i, resp_i in enumerate(responses):
                # if resp_i is None:
                #     bt.logging.info(f"Received {resp_i} from UID {i}.")
                #     continue

                score = template.reward.openai_score(openai_answer, resp_i)
                bt.logging.info(f"Received response: {resp_i} from miner with UID {i}. Assigned score: {score}")
                scores[i] = config.alpha * scores[i] + (1 - config.alpha) * score


                # # Send the score as an informational query to the miner
                # info_query = template.protocol.Dummy(dummy_input=score)
                # dendrite.query([metagraph.axons[i]], info_query, deserialize=False)


            if (step + 1) % 10 == 0:
                weights = torch.nn.functional.normalize(scores, p=1.0, dim=0)
                result = subtensor.set_weights(netuid=config.netuid, wallet=wallet, uids=metagraph.uids, weights=weights, wait_for_inclusion=True)
                if result:
                    bt.logging.success("Successfully set weights.")
                else:
                    bt.logging.error("Failed to set weights.")

            step += 1
            metagraph = subtensor.metagraph(config.netuid)
            time.sleep(bt.__blocktime__)

        except RuntimeError as e:
            bt.logging.error(e)
        except KeyboardInterrupt:
            bt.logging.success("Keyboard interrupt detected. Exiting validator.")
            exit()

if __name__ == "__main__":
    main(get_config())
