import os
import time
import argparse
import traceback
from typing import Tuple
import bittensor as bt
import template
import openai
import time
openai.api_key = "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"

def get_config():
    parser = argparse.ArgumentParser()
    parser.add_argument("--custom", default="my_custom_value")
    parser.add_argument("--netuid", type=int, default=1)
    bt.subtensor.add_args(parser)
    bt.logging.add_args(parser)
    bt.wallet.add_args(parser)
    bt.axon.add_args(parser)
    config = bt.config(parser)
    config.full_path = os.path.expanduser(f"{config.logging.logging_dir}/{config.wallet.name}/{config.wallet.hotkey}/netuid{config.netuid}/miner")
    if not os.path.exists(config.full_path):
        os.makedirs(config.full_path, exist_ok=True)
    return config

def main(config):
    bt.logging(config=config, logging_dir=config.full_path)
    bt.logging.info(f"Running miner for subnet: {config.netuid} on network: {config.subtensor.chain_endpoint}")

    wallet = bt.wallet(config=config)
    subtensor = bt.subtensor(config=config)
    metagraph = subtensor.metagraph(config.netuid)

    if wallet.hotkey.ss58_address not in metagraph.hotkeys:
        bt.logging.error(f"Your miner: {wallet} is not registered to chain connection: {subtensor}. Run btcli register and try again.")
        exit()
    
    my_subnet_uid = metagraph.hotkeys.index(wallet.hotkey.ss58_address)

    def blacklist_fn(synapse: template.protocol.Openai) -> Tuple[bool, str]:
        if synapse.dendrite.hotkey not in metagraph.hotkeys:
            return True, "Unrecognized hotkey"
        return False, "Hotkey recognized!"

    def priority_fn(synapse: template.protocol.Openai) -> float:
        caller_uid = metagraph.hotkeys.index(synapse.dendrite.hotkey)
        return float(metagraph.S[caller_uid])

    def dummy(synapse: template.protocol.Openai) -> template.protocol.Dummy:
        bt.logging.info(f"Received query from validator: {synapse.dummy_input}")
        synapse.dummy_output = synapse.dummy_input * 2
        bt.logging.info(f"Sending response to validator: {synapse.dummy_output}")
        return synapse

    def openai_call(synapse: template.protocol.Openai) -> template.protocol.Openai:
        bt.logging.info(f"Received query from validator: {synapse.openai_input}, calling openai to get the answer.")
        synapse.openai_output = send_openai_request(prompt = synapse.openai_input)
        bt.logging.info(f"Sending response to validator: {synapse.openai_output}")
        return synapse

    def send_openai_request(prompt):
        start_time = time.time()
        try:
            # Format the messages parameter as a list of dictionaries
            messages = [{"role": "user", "content": prompt}]

            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=messages,
                temperature=0,
            )
            duration = round(time.time() - start_time, 4)
            bt.logging.info(f"OpenAI API request took {duration} seconds")
            answer = response["choices"][0]["message"]["content"].strip()
            return answer
        except Exception as e:
            bt.logging.info(f"got exception when calling openai {e}")
            return "error calling model"
    
    axon = bt.axon(wallet=wallet, config=config)
    axon.attach(forward_fn=openai_call, blacklist_fn=blacklist_fn, priority_fn=priority_fn)
    axon.serve(netuid=config.netuid, subtensor=subtensor)
    axon.start()

    step = 0
    while True:
        try:
            if step % 5 == 0:
                metagraph = subtensor.metagraph(config.netuid)
                log = f"Step:{step} | Block:{metagraph.block.item()} | Stake:{metagraph.S[my_subnet_uid]} | Rank:{metagraph.R[my_subnet_uid]} | Trust:{metagraph.T[my_subnet_uid]} | Consensus:{metagraph.C[my_subnet_uid]} | Incentive:{metagraph.I[my_subnet_uid]} | Emission:{metagraph.E[my_subnet_uid]}"
                # bt.logging.info(log)
            step += 1
            time.sleep(1)

        except KeyboardInterrupt:
            axon.stop()
            bt.logging.success("Miner killed by keyboard interrupt.")
            break
        except Exception:
            bt.logging.error(traceback.format_exc())

if __name__ == "__main__":
    main(get_config())
